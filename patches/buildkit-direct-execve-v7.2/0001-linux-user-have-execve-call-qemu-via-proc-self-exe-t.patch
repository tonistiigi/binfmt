From c4d83d8ba49b373ec8a85e21f0fc272eefcbe8f8 Mon Sep 17 00:00:00 2001
From: CrazyMax <crazy-max@users.noreply.github.com>
Date: Sat, 17 Dec 2022 08:41:37 +0100
Subject: [PATCH] linux-user: have execve call qemu via /proc/self/exe to not
 rely on binfmt_misc

It is assumed that when a guest program calls execve syscall it wants to
execute a program on the same guest architecture and not the host architecture.

Previously, such a guest program would have execve syscall error out with:
"exec format error".

A common solution is to register the qemu binary in binfmt_misc but that is not a
userland-friendly solution, requiring to modify kernel state.

This patch injects /proc/self/exe as the first parameter and the qemu program name
as argv[0] to execve.

Signed-off-by: Tibor Vass <tibor@docker.com>
Signed-off-by: CrazyMax <crazy-max@users.noreply.github.com>
---
 linux-user/syscall.c | 39 ++++++++++++++++++++++++++++++---------
 1 file changed, 30 insertions(+), 9 deletions(-)

diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 24b25759be..91d971c6fb 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -8895,10 +8895,37 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
                 envc++;
             }
 
-            argp = g_new0(char *, argc + 1);
+            argp = g_new0(char *, argc + 4);
             envp = g_new0(char *, envc + 1);
 
-            for (gp = guest_argp, q = argp; gp;
+            if (!(p = lock_user_string(arg1)))
+                goto execve_efault;
+
+            /* if pathname is /proc/self/exe then retrieve the path passed to qemu via command line */
+            if (is_proc_myself(p, "exe")) {
+                CPUState *cpu = env_cpu((CPUArchState *)cpu_env);
+                TaskState *ts = cpu->opaque;
+                p = ts->bprm->filename;
+            }
+
+            /* retrieve guest argv0 */
+            if (get_user_ual(addr, guest_argp))
+                goto execve_efault;
+
+            /*
+             * From the guest, the call
+             * 		execve(pathname, [argv0, argv1], envp)
+             * on the host, becomes:
+             * 		execve("/proc/self/exe", [qemu_progname, "-0", argv0, pathname, argv1], envp)
+             * where qemu_progname is the error message prefix for qemu
+            */
+            argp[0] = (char*)error_get_progname();
+            argp[1] = (char*)"-0";
+            argp[2] = (char*)lock_user_string(addr);
+            argp[3] = p;
+
+            /* copy guest argv1 onwards to host argv4 onwards */
+            for (gp = guest_argp + 1*sizeof(abi_ulong), q = argp + 4; gp;
                   gp += sizeof(abi_ulong), q++) {
                 if (get_user_ual(addr, gp))
                     goto execve_efault;
@@ -8920,8 +8947,6 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
             }
             *q = NULL;
 
-            if (!(p = lock_user_string(arg1)))
-                goto execve_efault;
             /* Although execve() is not an interruptible syscall it is
              * a special case where we must use the safe_syscall wrapper:
              * if we allow a signal to happen before we make the host
@@ -8932,11 +8957,7 @@ static abi_long do_syscall1(CPUArchState *cpu_env, int num, abi_long arg1,
              * before the execve completes and makes it the other
              * program's problem.
              */
-            if (is_proc_myself(p, "exe")) {
-                ret = get_errno(safe_execve(exec_path, argp, envp));
-            } else {
-                ret = get_errno(safe_execve(p, argp, envp));
-            }
+            ret = get_errno(safe_execve("/proc/self/exe", argp, envp));
             unlock_user(p, arg1, 0);
 
             goto execve_end;
-- 
2.34.0

