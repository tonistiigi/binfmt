From 43aea3054fcbae1bfbfbb90edf1e3b56f439066f Mon Sep 17 00:00:00 2001
From: CrazyMax <crazy-max@users.noreply.github.com>
Date: Fri, 8 Sep 2023 10:47:29 +0200
Subject: [PATCH] linux-user: have execve call qemu via /proc/self/exe to not
 rely on binfmt_misc

It is assumed that when a guest program calls execve syscall it wants to
execute a program on the same guest architecture and not the host architecture.

Previously, such a guest program would have execve syscall error out with:
"exec format error".

A common solution is to register the qemu binary in binfmt_misc but that is not a
userland-friendly solution, requiring to modify kernel state.

This patch injects /proc/self/exe as the first parameter and the qemu program name
as argv[0] to execve.

Signed-off-by: Tibor Vass <tibor@docker.com>
Signed-off-by: CrazyMax <crazy-max@users.noreply.github.com>
---
 linux-user/syscall.c | 44 +++++++++++++++++++++++++++++++-------------
 1 file changed, 31 insertions(+), 13 deletions(-)

diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 9ee124c583..6ed502eb6c 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -8442,10 +8442,37 @@ static int do_execv(CPUArchState *cpu_env, int dirfd,
         envc++;
     }
 
-    argp = g_new0(char *, argc + 1);
+    argp = g_new0(char *, argc + 4);
     envp = g_new0(char *, envc + 1);
 
-    for (gp = guest_argp, q = argp; gp; gp += sizeof(abi_ulong), q++) {
+    if (!(p = lock_user_string(pathname)))
+        goto execve_efault;
+
+    /* if pathname is /proc/self/exe then retrieve the path passed to qemu via command line */
+    if (is_proc_myself(p, "exe")) {
+        CPUState *cpu = env_cpu((CPUArchState *)cpu_env);
+        TaskState *ts = cpu->opaque;
+        p = ts->bprm->filename;
+    }
+
+    /* retrieve guest argv0 */
+    if (get_user_ual(addr, guest_argp))
+        goto execve_efault;
+
+    /*
+     * From the guest, the call
+     * 		execve(pathname, [argv0, argv1], envp)
+     * on the host, becomes:
+     * 		execve("/proc/self/exe", [qemu_progname, "-0", argv0, pathname, argv1], envp)
+     * where qemu_progname is the error message prefix for qemu
+    */
+    argp[0] = (char*)error_get_progname();
+    argp[1] = (char*)"-0";
+    argp[2] = (char*)lock_user_string(addr);
+    argp[3] = p;
+
+    /* copy guest argv1 onwards to host argv4 onwards */
+    for (gp = guest_argp + 1*sizeof(abi_ulong), q = argp + 4; gp; gp += sizeof(abi_ulong), q++) {
         if (get_user_ual(addr, gp)) {
             goto execve_efault;
         }
@@ -8484,18 +8511,9 @@ static int do_execv(CPUArchState *cpu_env, int dirfd,
      * before the execve completes and makes it the other
      * program's problem.
      */
-    p = lock_user_string(pathname);
-    if (!p) {
-        goto execve_efault;
-    }
-
-    const char *exe = p;
-    if (is_proc_myself(p, "exe")) {
-        exe = exec_path;
-    }
     ret = is_execveat
-        ? safe_execveat(dirfd, exe, argp, envp, flags)
-        : safe_execve(exe, argp, envp);
+        ? safe_execveat(dirfd, "/proc/self/exe", argp, envp, flags)
+        : safe_execve("/proc/self/exe", argp, envp);
     ret = get_errno(ret);
 
     unlock_user(p, pathname, 0);
-- 
2.34.0

