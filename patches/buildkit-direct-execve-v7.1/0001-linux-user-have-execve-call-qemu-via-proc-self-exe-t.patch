From 4d6248d103cf749ab5a624903929d5d31754e09a Mon Sep 17 00:00:00 2001
From: Tibor Vass <tibor@docker.com>
Date: Mon, 1 Jun 2020 23:08:25 +0000
Subject: [PATCH] linux-user: have execve call qemu via /proc/self/exe to not
 rely on binfmt_misc

It is assumed that when a guest program calls execve syscall it wants to
execute a program on the same guest architecture and not the host architecture.

Previously, such a guest program would have execve syscall error out with:
"exec format error".

A common solution is to register the qemu binary in binfmt_misc but that is not a
userland-friendly solution, requiring to modify kernel state.

This patch injects /proc/self/exe as the first parameter and the qemu program name
as argv[0] to execve.

Signed-off-by: Tibor Vass <tibor@docker.com>
---
 linux-user/syscall.c | 35 ++++++++++++++++++++++++++++++-----
 1 file changed, 30 insertions(+), 5 deletions(-)

diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index f65045efe6..73054926a0 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -8776,10 +8776,37 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
                 envc++;
             }
 
-            argp = g_new0(char *, argc + 1);
+            argp = g_new0(char *, argc + 4);
             envp = g_new0(char *, envc + 1);
 
-            for (gp = guest_argp, q = argp; gp;
+            if (!(p = lock_user_string(arg1)))
+                goto execve_efault;
+
+            /* if pathname is /proc/self/exe then retrieve the path passed to qemu via command line */
+            if (is_proc_myself(p, "exe")) {
+                CPUState *cpu = env_cpu((CPUArchState *)cpu_env);
+                TaskState *ts = cpu->opaque;
+                p = ts->bprm->filename;
+            }
+
+            /* retrieve guest argv0 */
+            if (get_user_ual(addr, guest_argp))
+                goto execve_efault;
+
+            /*
+             * From the guest, the call
+             * 		execve(pathname, [argv0, argv1], envp)
+             * on the host, becomes:
+             * 		execve("/proc/self/exe", [qemu_progname, "-0", argv0, pathname, argv1], envp)
+             * where qemu_progname is the error message prefix for qemu
+            */
+            argp[0] = (char*)error_get_progname();
+            argp[1] = (char*)"-0";
+            argp[2] = (char*)lock_user_string(addr);
+            argp[3] = p;
+
+            /* copy guest argv1 onwards to host argv4 onwards */
+            for (gp = guest_argp + 1*sizeof(abi_ulong), q = argp + 4; gp;
                   gp += sizeof(abi_ulong), q++) {
                 if (get_user_ual(addr, gp))
                     goto execve_efault;
@@ -8801,8 +8828,6 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
             }
             *q = NULL;
 
-            if (!(p = lock_user_string(arg1)))
-                goto execve_efault;
             /* Although execve() is not an interruptible syscall it is
              * a special case where we must use the safe_syscall wrapper:
              * if we allow a signal to happen before we make the host
@@ -8813,7 +8838,7 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
              * before the execve completes and makes it the other
              * program's problem.
              */
-            ret = get_errno(safe_execve(p, argp, envp));
+            ret = get_errno(safe_execve("/proc/self/exe", argp, envp));
             unlock_user(p, arg1, 0);
 
             goto execve_end;
-- 
2.34.0

