From e69d0b167d541ce9a075b0f38ee76caf26700d25 Mon Sep 17 00:00:00 2001
From: Tibor Vass <tibor@docker.com>
Date: Thu, 18 Jun 2020 20:57:22 +0000
Subject: [PATCH 4/7] linux-user: support loading scripts with shebang (#!)

The interpreter is assumed to be compatible with the target architecture.

The script loading logic is taken from Linux source code to match logic as closely as possible.

An interpreter can itself be a script (#!/other.script), and thus load another interpreter.
This happens in a loop therefore the loading chain of interpreter-scripts is limited to 5 like in Linux.

Warning: there might be issues with m68k, mips, and mips64 architectures
since the cpu_model returned by those architectures (see linux-user/$arch/target_elf.h)
is dependent on the ELF header of the payload, but in this case the payload
is a script and not a binary.
	This could be fixed either by moving the loading logic or
parts of it to before the cpu_model is set, so that the final ELF binary is available.
An alternative fix is to avoid the loop altogether and call qemu binary again with different arguments.
The downside is that it would require one extra exec syscall per interpreter.

Signed-off-by: Tibor Vass <tibor@docker.com>
Signed-off-by: Tonis Tiigi <tonistiigi@gmail.com>
---
 linux-user/elfload.c   |   2 +-
 linux-user/linuxload.c | 140 +++++++++++++++++++++++++++++++++++------
 linux-user/loader.h    |   2 +
 3 files changed, 125 insertions(+), 19 deletions(-)

diff --git a/linux-user/elfload.c b/linux-user/elfload.c
index 60cf55b36c..b1c9903ac1 100644
--- a/linux-user/elfload.c
+++ b/linux-user/elfload.c
@@ -3811,10 +3811,10 @@ uint32_t get_elf_eflags(int fd)
         return 0;
     }
     ret = read(fd, &ehdr, sizeof(ehdr));
+    offset = lseek(fd, offset, SEEK_SET); /* reset seek regardless of error */
     if (ret < sizeof(ehdr)) {
         return 0;
     }
-    offset = lseek(fd, offset, SEEK_SET);
     if (offset == (off_t) -1) {
         return 0;
     }
diff --git a/linux-user/linuxload.c b/linux-user/linuxload.c
index 37f132be4a..7e66ef0ab9 100644
--- a/linux-user/linuxload.c
+++ b/linux-user/linuxload.c
@@ -142,7 +142,7 @@ int loader_exec(int fdexec, const char *filename, char **argv, char **envp,
                 struct target_pt_regs *regs, struct image_info *infop,
                 struct linux_binprm *bprm)
 {
-    int retval;
+    int retval, depth;
 
     bprm->src.fd = fdexec;
     bprm->filename = (char *)filename;
@@ -151,25 +151,33 @@ int loader_exec(int fdexec, const char *filename, char **argv, char **envp,
     bprm->envc = count(envp);
     bprm->envp = envp;
 
-    retval = prepare_binprm(bprm);
-
-    if (retval < 4) {
-        return -ENOEXEC;
-    }
-    if (bprm->buf[0] == 0x7f
-        && bprm->buf[1] == 'E'
-        && bprm->buf[2] == 'L'
-        && bprm->buf[3] == 'F') {
-        retval = load_elf_binary(bprm, infop);
+    for (depth = 0; ; depth++) {
+        if (depth > 5) {
+            return -ELOOP;
+        }
+        retval = prepare_binprm(bprm);
+        if (retval >= 0) {
+            if (bprm->buf[0] == 0x7f
+                    && bprm->buf[1] == 'E'
+                    && bprm->buf[2] == 'L'
+                    && bprm->buf[3] == 'F') {
+                retval = load_elf_binary(bprm, infop);
 #if defined(TARGET_HAS_BFLT)
-    } else if (bprm->buf[0] == 'b'
-               && bprm->buf[1] == 'F'
-               && bprm->buf[2] == 'L'
-               && bprm->buf[3] == 'T') {
-        retval = load_flt_binary(bprm, infop);
+            } else if (bprm->buf[0] == 'b'
+                        && bprm->buf[1] == 'F'
+                        && bprm->buf[2] == 'L'
+                        && bprm->buf[3] == 'T') {
+                    retval = load_flt_binary(bprm, infop);
 #endif
-    } else {
-        return -ENOEXEC;
+            } else if (bprm->buf[0] == '#'
+                    && bprm->buf[1] == '!') {
+                retval = load_script(bprm);
+                if (retval >= 0) continue;
+            } else {
+                return -ENOEXEC;
+            }
+        }
+        break;
     }
     if (retval < 0) {
         return retval;
@@ -180,6 +188,102 @@ int loader_exec(int fdexec, const char *filename, char **argv, char **envp,
     return 0;
 }
 
+static inline bool spacetab(char c) { return c == ' ' || c == '\t'; }
+static inline const char *next_non_spacetab(const char *first, const char *last)
+{
+    for (; first <= last; first++)
+        if (!spacetab(*first))
+            return first;
+    return NULL;
+}
+static inline const char *next_terminator(const char *first, const char *last)
+{
+    for (; first <= last; first++)
+        if (spacetab(*first) || !*first)
+            return first;
+    return NULL;
+}
+
+/*
+ * Reads the interpreter (shebang #!) line and modifies bprm object accordingly
+ * This is a modified version of Linux's load_script function.
+*/
+int load_script(struct linux_binprm *bprm)
+{
+    const char *i_name, *i_sep, *i_arg, *i_end, *buf_end;
+    int execfd, i, argc_delta;
+
+    buf_end = bprm->buf + sizeof(bprm->buf) - 1;
+    i_end = (const char*)memchr(bprm->buf, '\n', sizeof(bprm->buf));
+    if (!i_end) {
+        i_end = next_non_spacetab(bprm->buf + 2, buf_end);
+        if (!i_end) {
+            perror("script_prepare_binprm: no interpreter name found");
+            return -ENOEXEC; /* Entire buf is spaces/tabs */
+        }
+        /*
+         * If there is no later space/tab/NUL we must assume the
+         * interpreter path is truncated.
+         */
+        if (!next_terminator(i_end, buf_end)) {
+            perror("script_prepare_binprm: truncated interpreter path");
+            return -ENOEXEC;
+        }
+        i_end = buf_end;
+    }
+    /* Trim any trailing spaces/tabs from i_end */
+    while (spacetab(i_end[-1]))
+        i_end--;
+    *((char *)i_end) = '\0';
+    /* Skip over leading spaces/tabs */
+    i_name = next_non_spacetab(bprm->buf+2, i_end);
+    if (!i_name || (i_name == i_end)) {
+        perror("script_prepare_binprm: no interpreter name found");
+        return -ENOEXEC; /* No interpreter name found */
+    }
+
+    /* Is there an optional argument? */
+    i_arg = NULL;
+    i_sep = next_terminator(i_name, i_end);
+    if (i_sep && (*i_sep != '\0')) {
+        i_arg = next_non_spacetab(i_sep, i_end);
+        *((char *)i_sep) = '\0';
+    }
+
+    /*
+     * OK, we've parsed out the interpreter name and
+     * (optional) argument.
+     * Splice in (1) the interpreter's name for argv[0]
+     *           (2) (optional) argument to interpreter
+     *           (3) filename of shell script (replace argv[0])
+     *           (4) user arguments (argv[1:])
+     */
+
+    execfd = open(i_name, O_RDONLY);
+    if (execfd < 0) {
+        perror("script_prepare_binprm: could not open script");
+        return -ENOEXEC; /* Could not open interpreter */
+    }
+
+    argc_delta = 1 /* extra filename */ + (i_arg ? 1 : 0);
+    bprm->argc += argc_delta;
+    bprm->argv = realloc(bprm->argv, sizeof(char*) * (bprm->argc + 1));
+
+    /* shift argv by argc_delta */
+    for (i = bprm->argc; i >= argc_delta; i--)
+        bprm->argv[i] = bprm->argv[i-argc_delta];
+
+    bprm->argv[0] = (char *)strdup(i_name);
+    if (i_arg)
+        bprm->argv[1] = (char *)strdup(i_arg);
+
+    bprm->src.fd = execfd; /* not closing fd as it is needed for the duration of the program */
+    bprm->filename = (char *)strdup(i_name); /* replace filename with script interpreter */
+    /* envc and envp are kept unchanged */
+
+    return 0;
+}
+
 bool imgsrc_read(void *dst, off_t offset, size_t len,
                  const ImageSource *img, Error **errp)
 {
diff --git a/linux-user/loader.h b/linux-user/loader.h
index e102e6f410..c532d91016 100644
--- a/linux-user/loader.h
+++ b/linux-user/loader.h
@@ -98,6 +98,8 @@ abi_long memcpy_to_target(abi_ulong dest, const void *src,
 
 extern unsigned long guest_stack_size;
 
+int load_script(struct linux_binprm *bprm);
+
 #if defined(TARGET_S390X) || defined(TARGET_AARCH64) || defined(TARGET_ARM)
 uint32_t get_elf_hwcap(void);
 const char *elf_hwcap_str(uint32_t bit);
-- 
2.39.3 (Apple Git-146)

