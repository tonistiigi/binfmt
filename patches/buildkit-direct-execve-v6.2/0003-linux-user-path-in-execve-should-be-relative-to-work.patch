From 995482a634d12891bcf0d22bb6cc3b6e6bdb0deb Mon Sep 17 00:00:00 2001
From: Tibor Vass <tibor@docker.com>
Date: Sat, 27 Jun 2020 21:42:51 +0000
Subject: [PATCH 3/5] linux-user: path in execve should be relative to working
 dir

Fixes regression introduced in parent commit where PATH handling was introduced.

When guest calls execve(filename, argp, envp) filename can be relative in which
case Linux makes it relative to the working directory.

However, since execve is now handled by exec-ing qemu process again, filename
would first get looked up in PATH in main() before calling host's execve.

With this change, if filename is relative and exists in working directory as
well as in PATH, working directory will get precedence over PATH if guest is
doing an execve syscall, but not if relative filename comes from qemu's argv.

Signed-off-by: Tibor Vass <tibor@docker.com>
---
 include/qemu/path.h  |  1 +
 linux-user/syscall.c |  9 +++++++--
 util/path.c          | 30 ++++++++++++++++++++++++++++++
 3 files changed, 38 insertions(+), 2 deletions(-)

diff --git a/include/qemu/path.h b/include/qemu/path.h
index c6292a9709..a81fb51e1f 100644
--- a/include/qemu/path.h
+++ b/include/qemu/path.h
@@ -3,5 +3,6 @@
 
 void init_paths(const char *prefix);
 const char *path(const char *pathname);
+const char *prepend_workdir_if_relative(const char *path);
 
 #endif
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 47c41ed06e..51bab2da89 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -8570,12 +8570,17 @@ static abi_long do_syscall1(void *cpu_env, int num, abi_long arg1,
              * 		execve(pathname, [argv0, argv1], envp)
              * on the host, becomes:
              * 		execve("/proc/self/exe", [qemu_progname, "-0", argv0, pathname, argv1], envp)
-             * where qemu_progname is the error message prefix for qemu
+             * where qemu_progname is the error message prefix for qemu.
+             * Note: if pathname is relative, it will be prepended with the current working directory.
             */
             argp[0] = (char*)error_get_progname();
             argp[1] = (char*)"-0";
             argp[2] = (char*)lock_user_string(addr);
-            argp[3] = p;
+            argp[3] = (char*)prepend_workdir_if_relative(p);
+            if (!argp[3]) {
+                ret = -host_to_target_errno(errno);
+                goto execve_end;
+            }
 
             /* copy guest argv1 onwards to host argv4 onwards */
             for (gp = guest_argp + 1*sizeof(abi_ulong), q = argp + 4; gp;
diff --git a/util/path.c b/util/path.c
index 8e174eb436..f7907b8238 100644
--- a/util/path.c
+++ b/util/path.c
@@ -68,3 +68,33 @@ const char *path(const char *name)
     qemu_mutex_unlock(&lock);
     return ret;
 }
+
+/* Prepends working directory if path is relative.
+ * If path is absolute, it is returned as-is without any allocation.
+ * Otherwise, caller is responsible to free returned path.
+ * Returns NULL and sets errno upon error.
+ * Note: realpath is not called to let the kernel do the rest of the resolution.
+ */
+const char *prepend_workdir_if_relative(const char *path)
+{
+    char buf[PATH_MAX];
+    char *p;
+    int i, j, k;
+
+    if (!path || path[0] == '/') return path;
+
+    if (!getcwd(buf, PATH_MAX)) return NULL;
+    i = strlen(buf);
+    j = strlen(path);
+    k = i + 1 + j + 1; /* workdir + '/' + path + '\0' */
+    if (i + j > PATH_MAX) {
+        errno = ERANGE;
+        return NULL;
+    }
+    if (!(p = malloc(k * sizeof(char*)))) return NULL;
+
+    if (!strncat(p, buf, i)) return NULL;
+    if (!strncat(p, "/", 1)) return NULL;
+    if (!strncat(p, path, j)) return NULL;
+    return p;
+}
-- 
2.32.0 (Apple Git-132)

